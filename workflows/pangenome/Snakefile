import os
from pathlib import Path

# Load config - all paths and parameters will come from config
configfile: "config.yaml"

# All paths from config
REFERENCE = config["reference"]
HAPLOTYPE_FASTAS = config["haplotype_fastas"]
OUTPUT_DIR = config["output_dir"]
VG_DOCKER = config.get("vg_docker", "quay.io/vgteam/vg:v1.65.0")
THREADS = config.get("threads", 4)
MOUNT_DIR = config["mount_dir"]

# Get current user ID and group ID for Docker
USER_ID = os.getuid()
GROUP_ID = os.getgid()

# Create output directory
Path(OUTPUT_DIR).mkdir(parents=True, exist_ok=True)

# Final outputs
rule all:
    input:
        os.path.join(OUTPUT_DIR, "pangenome.gfa"),
        os.path.join(OUTPUT_DIR, "pangenome_stats.txt"),
        os.path.join(OUTPUT_DIR, "sample_alignments.paf")

# Create combined FASTA with all sequences
rule combine_sequences:
    input:
        ref=REFERENCE,
        haplotypes=HAPLOTYPE_FASTAS
    output:
        combined=os.path.join(OUTPUT_DIR, "all_sequences.fa")
    log:
        os.path.join(OUTPUT_DIR, "logs", "combine_sequences.log")
    run:
        # Create logs directory
        Path(str(log)).parent.mkdir(parents=True, exist_ok=True)
        
        with open(str(output.combined), 'w') as out:
            # Add reference sequences, preserving original chromosome names
            print(f"Adding reference: {input.ref}", file=open(str(log), 'w'))
            with open(str(input.ref)) as f:
                for line in f:
                    if line.startswith('>'):
                        # Extract chromosome name from header (everything after > until first space)
                        chrom_name = line[1:].split()[0]
                        out.write(f'>{chrom_name}\n')
                        print(f"  Added chromosome: {chrom_name}", file=open(str(log), 'a'))
                    else:
                        out.write(line)
            
            # Add each haplotype
            sorted_haplotypes = sorted(input.haplotypes)
            for var_path in sorted_haplotypes:
                haplotype_name = Path(var_path).stem 
                print(f"Adding haplotype {haplotype_name}: {var_path}", file=open(str(log), 'a'))
                with open(var_path) as f:
                    for line in f:
                        if line.startswith('>'):
                            # Extract chromosome name and append haplotype suffix
                            chrom_name = line[1:].split()[0]
                            out.write(f'>{chrom_name}#{haplotype_name}\n')
                            print(f"  Added haplotype sequence: {chrom_name}#{haplotype_name}", file=open(str(log), 'a'))
                        else:
                            out.write(line)

# Create all-vs-all alignment
rule align_all:
    input:
        seqs=os.path.join(OUTPUT_DIR, "all_sequences.fa")
    output:
        paf=os.path.join(OUTPUT_DIR, "sample_alignments.paf")
    threads: THREADS
    log:
        os.path.join(OUTPUT_DIR, "logs", "align_all.log")
    shell:
        """
        mkdir -p $(dirname {log})
        minimap2 -x asm20 -X -c -t {threads} {input.seqs} {input.seqs} > {output.paf} 2> {log}
        echo "Alignment complete. Lines in PAF:" >> {log}
        wc -l {output.paf} >> {log}
        """

# Build pangenome using vg construct with MSA mode
rule build_pangenome:
    input:
        seqs=os.path.join(OUTPUT_DIR, "all_sequences.fa")
    output:
        vg=os.path.join(OUTPUT_DIR, "pangenome.vg"),
        gfa=os.path.join(OUTPUT_DIR, "pangenome.gfa")
    threads: THREADS
    log:
        os.path.join(OUTPUT_DIR, "logs", "build_pangenome.log")
    params:
        mount_dir=MOUNT_DIR,
        docker_image=VG_DOCKER,
        user_id=USER_ID,
        group_id=GROUP_ID
    shell:
        """
        mkdir -p $(dirname {log})
        
        # Build graph using vg construct with MSA mode
        echo "Building pangenome graph with vg construct (MSA mode)..." > {log}
        echo "Running as user {params.user_id}:{params.group_id}" >> {log}
        
        # Create relative paths for Docker (relative to mount point)
        REL_SEQS=$(realpath --relative-to={params.mount_dir} {input.seqs})
        REL_VG=$(realpath --relative-to={params.mount_dir} {output.vg})
        REL_GFA=$(realpath --relative-to={params.mount_dir} {output.gfa})
        
        echo "Mount dir: {params.mount_dir}" >> {log}
        echo "Input sequences: {input.seqs} -> $REL_SEQS" >> {log}
        echo "Output VG: {output.vg} -> $REL_VG" >> {log}
        echo "Output GFA: {output.gfa} -> $REL_GFA" >> {log}
        
        # Ensure output directory exists in container
        OUTPUT_REL_DIR=$(dirname "$REL_VG")
        
        # Run vg construct with MSA mode - this treats the FASTA as multiple sequences
        echo "Running vg construct with MSA mode..." >> {log}
        docker run --rm \
            --user {params.user_id}:{params.group_id} \
            -v {params.mount_dir}:/data \
            -w /data \
            {params.docker_image} \
            bash -c "mkdir -p '$OUTPUT_REL_DIR' && vg construct -M '$REL_SEQS' -t {threads}" > {output.vg} 2>> {log}
        
        # Check if VG file was created
        if [ ! -f {output.vg} ]; then
            echo "ERROR: VG file was not created" >> {log}
            cat {log}
            exit 1
        fi
        
        # Convert to GFA
        echo "Converting to GFA..." >> {log}
        docker run --rm \
            --user {params.user_id}:{params.group_id} \
            -v {params.mount_dir}:/data \
            -w /data \
            {params.docker_image} \
            vg view -g "$REL_VG" > {output.gfa} 2>> {log}
        
        # Check if GFA file was created
        if [ ! -f {output.gfa} ]; then
            echo "ERROR: GFA file was not created" >> {log}
            cat {log}
            exit 1
        fi
        
        echo "Pangenome construction completed successfully" >> {log}
        """

# Generate statistics
rule graph_stats:
    input:
        vg=os.path.join(OUTPUT_DIR, "pangenome.vg"),
        gfa=os.path.join(OUTPUT_DIR, "pangenome.gfa"),
        paf=os.path.join(OUTPUT_DIR, "sample_alignments.paf")
    output:
        stats=os.path.join(OUTPUT_DIR, "pangenome_stats.txt")
    params:
        mount_dir=MOUNT_DIR,
        docker_image=VG_DOCKER,
        user_id=USER_ID,
        group_id=GROUP_ID
    shell:
        """
        echo "=== Pangenome Statistics ===" > {output.stats}
        echo "" >> {output.stats}
        
        echo "Graph structure:" >> {output.stats}
        REL_VG=$(realpath --relative-to={params.mount_dir} {input.vg})
        docker run --rm \
            --user {params.user_id}:{params.group_id} \
            -v {params.mount_dir}:/data \
            -w /data \
            {params.docker_image} \
            vg stats -z "$REL_VG" >> {output.stats}
        
        echo -e "\nPaths in graph:" >> {output.stats}
        docker run --rm \
            --user {params.user_id}:{params.group_id} \
            -v {params.mount_dir}:/data \
            -w /data \
            {params.docker_image} \
            vg paths -v "$REL_VG" -L >> {output.stats} 2>/dev/null || echo "No paths found" >> {output.stats}
        
        echo -e "\nGFA summary:" >> {output.stats}
        echo -n "Nodes: " >> {output.stats}
        grep -c '^S' {input.gfa} >> {output.stats} || echo "0" >> {output.stats}
        echo -n "Edges: " >> {output.stats}
        grep -c '^L' {input.gfa} >> {output.stats} || echo "0" >> {output.stats}
        echo -n "Paths: " >> {output.stats}
        grep -c '^P' {input.gfa} >> {output.stats} || echo "0" >> {output.stats}
        
        echo -e "\nAlignment summary:" >> {output.stats}
        echo -n "Total alignments: " >> {output.stats}
        wc -l < {input.paf} >> {output.stats}
        """
